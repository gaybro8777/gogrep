// Copyright (c) 2017, Daniel Mart√≠ <mvdan@mvdan.cc>
// See LICENSE for licensing information

package nls

import (
	"fmt"
	"go/ast"
	"go/importer"
	"go/token"
	"go/types"
	"strconv"

	"mvdan.cc/gogrep/gsyntax"
)

func valsCopy(values map[string]ast.Node) map[string]ast.Node {
	v2 := make(map[string]ast.Node, len(values))
	for k, v := range values {
		v2[k] = v
	}
	return v2
}

func nodeLists(n ast.Node) []gsyntax.NodeList {
	var lists []gsyntax.NodeList
	addList := func(list gsyntax.NodeList) {
		if list.Len() > 0 {
			lists = append(lists, list)
		}
	}
	switch x := n.(type) {
	case gsyntax.NodeList:
		addList(x)
	case *ast.CompositeLit:
		addList(gsyntax.ExprList(x.Elts))
	case *ast.CallExpr:
		addList(gsyntax.ExprList(x.Args))
	case *ast.AssignStmt:
		addList(gsyntax.ExprList(x.Lhs))
		addList(gsyntax.ExprList(x.Rhs))
	case *ast.ReturnStmt:
		addList(gsyntax.ExprList(x.Results))
	case *ast.ValueSpec:
		addList(gsyntax.ExprList(x.Values))
	case *ast.BlockStmt:
		addList(gsyntax.StmtList(x.List))
	case *ast.CaseClause:
		addList(gsyntax.ExprList(x.List))
		addList(gsyntax.StmtList(x.Body))
	case *ast.CommClause:
		addList(gsyntax.StmtList(x.Body))
	}
	return lists
}

func (g *G) walkWithLists(exprNode, node ast.Node, fn func(exprNode, node ast.Node)) {
	visit := func(node ast.Node) bool {
		fn(exprNode, node)
		for _, list := range nodeLists(node) {
			fn(exprNode, list)
			if id := g.wildAnyIdent(exprNode); id != nil {
				// so that "$*a" will match "a, b"
				fn(gsyntax.ExprList([]ast.Expr{id}), list)
				// so that "$*a" will match "a; b"
				fn(toStmtList(id), list)
			}
		}
		return true
	}
	gsyntax.Inspect(node, visit)
}

func (g *G) topNode(exprNode, node ast.Node) ast.Node {
	sts1, ok1 := exprNode.(gsyntax.StmtList)
	sts2, ok2 := node.(gsyntax.StmtList)
	if ok1 && ok2 {
		// allow a partial match at the top level
		return g.nodes(sts1, sts2, true)
	}
	if g.node(exprNode, node) {
		return node
	}
	return nil
}

// optNode is like node, but for those nodes that can be nil and are not
// part of a list. For example, init and post statements in a for loop.
func (g *G) optNode(expr, node ast.Node) bool {
	if ident := g.wildAnyIdent(expr); ident != nil {
		if g.node(toStmtList(ident), toStmtList(node)) {
			return true
		}
	}
	return g.node(expr, node)
}

func (g *G) node(expr, node ast.Node) bool {
	switch node.(type) {
	case *ast.File, *ast.FuncType, *ast.BlockStmt, *ast.IfStmt,
		*ast.SwitchStmt, *ast.TypeSwitchStmt, *ast.CaseClause,
		*ast.CommClause, *ast.ForStmt, *ast.RangeStmt:
		if scope := g.Info.Scopes[node]; scope != nil {
			g.Scope = scope
		}
	}
	if !g.aggressive {
		if expr == nil || node == nil {
			return expr == node
		}
	} else {
		if expr == nil && node == nil {
			return true
		}
		if node == nil {
			expr, node = node, expr
		}
	}
	switch x := expr.(type) {
	case nil: // only in aggressive mode
		y, ok := node.(*ast.Ident)
		return ok && y.Name == "_"

	case *ast.File:
		y, ok := node.(*ast.File)
		if !ok || !g.node(x.Name, y.Name) || len(x.Decls) != len(y.Decls) ||
			len(x.Imports) != len(y.Imports) {
			return false
		}
		for i, decl := range x.Decls {
			if !g.node(decl, y.Decls[i]) {
				return false
			}
		}
		for i, imp := range x.Imports {
			if !g.node(imp, y.Imports[i]) {
				return false
			}
		}
		return true

	case *ast.Ident:
		y, yok := node.(*ast.Ident)
		if !isWildName(x.Name) {
			// not a wildcard
			return yok && x.Name == y.Name
		}
		if _, ok := node.(ast.Node); !ok {
			return false // to not include our extra node types
		}
		id := fromWildName(x.Name)
		info := g.info(id)
		if info.any {
			return false
		}
		if info.name == "_" {
			// values are discarded, matches anything
			return true
		}
		prev, ok := g.values[info.name]
		if !ok {
			// first occurrence, record value
			g.values[info.name] = node
			return true
		}
		// multiple uses must match
		return g.node(prev, node)

	// lists (ys are generated by us while walking)
	case gsyntax.ExprList:
		y, ok := node.(gsyntax.ExprList)
		return ok && g.exprs(x, y)
	case gsyntax.StmtList:
		y, ok := node.(gsyntax.StmtList)
		return ok && g.stmts(x, y)

	// lits
	case *ast.BasicLit:
		y, ok := node.(*ast.BasicLit)
		return ok && x.Kind == y.Kind && x.Value == y.Value
	case *ast.CompositeLit:
		y, ok := node.(*ast.CompositeLit)
		return ok && g.node(x.Type, y.Type) && g.exprs(x.Elts, y.Elts)
	case *ast.FuncLit:
		y, ok := node.(*ast.FuncLit)
		return ok && g.node(x.Type, y.Type) && g.node(x.Body, y.Body)

	// types
	case *ast.ArrayType:
		y, ok := node.(*ast.ArrayType)
		return ok && g.node(x.Len, y.Len) && g.node(x.Elt, y.Elt)
	case *ast.MapType:
		y, ok := node.(*ast.MapType)
		return ok && g.node(x.Key, y.Key) && g.node(x.Value, y.Value)
	case *ast.StructType:
		y, ok := node.(*ast.StructType)
		return ok && g.fields(x.Fields, y.Fields)
	case *ast.Field:
		// TODO: tags?
		y, ok := node.(*ast.Field)
		if !ok {
			return false
		}
		if len(x.Names) == 0 && x.Tag == nil && g.node(x.Type, y) {
			// Allow $var to match a field.
			return true
		}
		return g.idents(x.Names, y.Names) && g.node(x.Type, y.Type)
	case *ast.FuncType:
		y, ok := node.(*ast.FuncType)
		return ok && g.fields(x.Params, y.Params) &&
			g.fields(x.Results, y.Results)
	case *ast.InterfaceType:
		y, ok := node.(*ast.InterfaceType)
		return ok && g.fields(x.Methods, y.Methods)
	case *ast.ChanType:
		y, ok := node.(*ast.ChanType)
		return ok && x.Dir == y.Dir && g.node(x.Value, y.Value)

	// other exprs
	case *ast.Ellipsis:
		y, ok := node.(*ast.Ellipsis)
		return ok && g.node(x.Elt, y.Elt)
	case *ast.ParenExpr:
		y, ok := node.(*ast.ParenExpr)
		return ok && g.node(x.X, y.X)
	case *ast.UnaryExpr:
		y, ok := node.(*ast.UnaryExpr)
		return ok && x.Op == y.Op && g.node(x.X, y.X)
	case *ast.BinaryExpr:
		y, ok := node.(*ast.BinaryExpr)
		return ok && x.Op == y.Op && g.node(x.X, y.X) && g.node(x.Y, y.Y)
	case *ast.CallExpr:
		y, ok := node.(*ast.CallExpr)
		return ok && g.node(x.Fun, y.Fun) && g.exprs(x.Args, y.Args) &&
			bothValid(x.Ellipsis, y.Ellipsis)
	case *ast.KeyValueExpr:
		y, ok := node.(*ast.KeyValueExpr)
		return ok && g.node(x.Key, y.Key) && g.node(x.Value, y.Value)
	case *ast.StarExpr:
		y, ok := node.(*ast.StarExpr)
		return ok && g.node(x.X, y.X)
	case *ast.SelectorExpr:
		y, ok := node.(*ast.SelectorExpr)
		return ok && g.node(x.X, y.X) && g.node(x.Sel, y.Sel)
	case *ast.IndexExpr:
		y, ok := node.(*ast.IndexExpr)
		return ok && g.node(x.X, y.X) && g.node(x.Index, y.Index)
	case *ast.SliceExpr:
		y, ok := node.(*ast.SliceExpr)
		return ok && g.node(x.X, y.X) && g.node(x.Low, y.Low) &&
			g.node(x.High, y.High) && g.node(x.Max, y.Max)
	case *ast.TypeAssertExpr:
		y, ok := node.(*ast.TypeAssertExpr)
		return ok && g.node(x.X, y.X) && g.node(x.Type, y.Type)

	// decls
	case *ast.GenDecl:
		y, ok := node.(*ast.GenDecl)
		return ok && x.Tok == y.Tok && g.specs(x.Specs, y.Specs)
	case *ast.FuncDecl:
		y, ok := node.(*ast.FuncDecl)
		return ok && g.fields(x.Recv, y.Recv) && g.node(x.Name, y.Name) &&
			g.node(x.Type, y.Type) && g.node(x.Body, y.Body)

	// specs
	case *ast.ValueSpec:
		y, ok := node.(*ast.ValueSpec)
		if !ok || !g.node(x.Type, y.Type) {
			return false
		}
		if g.aggressive && len(x.Names) == 1 {
			for i := range y.Names {
				if g.node(x.Names[i], y.Names[i]) &&
					(x.Values == nil || g.node(x.Values[i], y.Values[i])) {
					return true
				}
			}
		}
		return g.idents(x.Names, y.Names) && g.exprs(x.Values, y.Values)

	// stmt bridge nodes
	case *ast.ExprStmt:
		if id, ok := x.X.(*ast.Ident); ok && isWildName(id.Name) {
			// prefer matching $x as a statement, as it's
			// the parent
			return g.node(id, node)
		}
		y, ok := node.(*ast.ExprStmt)
		return ok && g.node(x.X, y.X)
	case *ast.DeclStmt:
		y, ok := node.(*ast.DeclStmt)
		return ok && g.node(x.Decl, y.Decl)

	// stmts
	case *ast.EmptyStmt:
		_, ok := node.(*ast.EmptyStmt)
		return ok
	case *ast.LabeledStmt:
		y, ok := node.(*ast.LabeledStmt)
		return ok && g.node(x.Label, y.Label) && g.node(x.Stmt, y.Stmt)
	case *ast.SendStmt:
		y, ok := node.(*ast.SendStmt)
		return ok && g.node(x.Chan, y.Chan) && g.node(x.Value, y.Value)
	case *ast.IncDecStmt:
		y, ok := node.(*ast.IncDecStmt)
		return ok && x.Tok == y.Tok && g.node(x.X, y.X)
	case *ast.AssignStmt:
		y, ok := node.(*ast.AssignStmt)
		if !g.aggressive {
			return ok && x.Tok == y.Tok &&
				g.exprs(x.Lhs, y.Lhs) && g.exprs(x.Rhs, y.Rhs)
		}
		if ok {
			return g.exprs(x.Lhs, y.Lhs) && g.exprs(x.Rhs, y.Rhs)
		}
		vs, ok := node.(*ast.ValueSpec)
		return ok && g.nodesMatch(gsyntax.ExprList(x.Lhs), gsyntax.IdentList(vs.Names)) &&
			g.exprs(x.Rhs, vs.Values)
	case *ast.GoStmt:
		y, ok := node.(*ast.GoStmt)
		return ok && g.node(x.Call, y.Call)
	case *ast.DeferStmt:
		y, ok := node.(*ast.DeferStmt)
		return ok && g.node(x.Call, y.Call)
	case *ast.ReturnStmt:
		y, ok := node.(*ast.ReturnStmt)
		return ok && g.exprs(x.Results, y.Results)
	case *ast.BranchStmt:
		y, ok := node.(*ast.BranchStmt)
		return ok && x.Tok == y.Tok && g.node(maybeNilIdent(x.Label), maybeNilIdent(y.Label))
	case *ast.BlockStmt:
		if g.aggressive && g.node(gsyntax.StmtList(x.List), node) {
			return true
		}
		y, ok := node.(*ast.BlockStmt)
		if !ok {
			return false
		}
		if x == nil || y == nil {
			return x == y
		}
		return g.cases(x.List, y.List) || g.stmts(x.List, y.List)
	case *ast.IfStmt:
		y, ok := node.(*ast.IfStmt)
		if !ok {
			return false
		}
		condAny := g.wildAnyIdent(x.Cond)
		if condAny != nil && x.Init == nil {
			// if $*x { ... } on the left
			left := toStmtList(condAny)
			return g.node(left, toStmtList(y.Init, y.Cond)) &&
				g.node(x.Body, y.Body) && g.optNode(x.Else, y.Else)
		}
		return g.optNode(x.Init, y.Init) && g.node(x.Cond, y.Cond) &&
			g.node(x.Body, y.Body) && g.node(x.Else, y.Else)
	case *ast.CaseClause:
		y, ok := node.(*ast.CaseClause)
		return ok && g.exprs(x.List, y.List) && g.stmts(x.Body, y.Body)
	case *ast.SwitchStmt:
		y, ok := node.(*ast.SwitchStmt)
		if !ok {
			return false
		}
		tagAny := g.wildAnyIdent(x.Tag)
		if tagAny != nil && x.Init == nil {
			// switch $*x { ... } on the left
			left := toStmtList(tagAny)
			return g.node(left, toStmtList(y.Init, y.Tag)) &&
				g.node(x.Body, y.Body)
		}
		return g.optNode(x.Init, y.Init) && g.node(x.Tag, y.Tag) && g.node(x.Body, y.Body)
	case *ast.TypeSwitchStmt:
		y, ok := node.(*ast.TypeSwitchStmt)
		return ok && g.optNode(x.Init, y.Init) && g.node(x.Assign, y.Assign) && g.node(x.Body, y.Body)
	case *ast.CommClause:
		y, ok := node.(*ast.CommClause)
		return ok && g.node(x.Comm, y.Comm) && g.stmts(x.Body, y.Body)
	case *ast.SelectStmt:
		y, ok := node.(*ast.SelectStmt)
		return ok && g.node(x.Body, y.Body)
	case *ast.ForStmt:
		condIdent := g.wildAnyIdent(x.Cond)
		if condIdent != nil && x.Init == nil && x.Post == nil {
			// "for $*x { ... }" on the left
			left := toStmtList(condIdent)
			// also accept RangeStmt on the right
			switch y := node.(type) {
			case *ast.ForStmt:
				return g.node(left, toStmtList(y.Init, y.Cond, y.Post)) &&
					g.node(x.Body, y.Body)
			case *ast.RangeStmt:
				return g.node(left, toStmtList(y.Key, y.Value, y.X)) &&
					g.node(x.Body, y.Body)
			default:
				return false
			}
		}
		y, ok := node.(*ast.ForStmt)
		if !ok {
			return false
		}
		return g.optNode(x.Init, y.Init) && g.node(x.Cond, y.Cond) &&
			g.optNode(x.Post, y.Post) && g.node(x.Body, y.Body)
	case *ast.RangeStmt:
		y, ok := node.(*ast.RangeStmt)
		if !ok {
			return false
		}
		if !g.aggressive && x.Tok != y.Tok {
			return false
		}
		return g.node(x.Key, y.Key) && g.node(x.Value, y.Value) &&
			g.node(x.X, y.X) && g.node(x.Body, y.Body)

	case *ast.TypeSpec:
		y, ok := node.(*ast.TypeSpec)
		return ok && g.node(x.Name, y.Name) && g.node(x.Type, y.Type)

	case *ast.FieldList:
		// we ignore these, for now
		return false
	default:
		panic(fmt.Sprintf("unexpected node: %T", x))
	}
}

func (g *G) wildAnyIdent(node ast.Node) *ast.Ident {
	switch x := node.(type) {
	case *ast.ExprStmt:
		return g.wildAnyIdent(x.X)
	case *ast.Ident:
		if !isWildName(x.Name) {
			return nil
		}
		if !g.info(fromWildName(x.Name)).any {
			return nil
		}
		return x
	}
	return nil
}

func (g *G) resolveTypeStr(expr string) types.Type {
	exp, _, err := gsyntax.ParseType(g.Fset, expr)
	if err != nil {
		g.Fatal(err)
	}
	typ := g.resolveType(g.Scope, exp)
	if typ == nil {
		g.Fatal(fmt.Errorf("unknown type: %q", expr))
	}
	return typ
}

// resolveType resolves a type expression from a given scope.
func (g *G) resolveType(scope *types.Scope, expr ast.Expr) types.Type {
	switch x := expr.(type) {
	case *ast.Ident:
		_, obj := scope.LookupParent(x.Name, token.NoPos)
		if obj == nil {
			// TODO: error if all resolveType calls on a type
			// expression fail? or perhaps resolve type expressions
			// across the entire program?
			return nil
		}
		return obj.Type()
	case *ast.ArrayType:
		elt := g.resolveType(scope, x.Elt)
		if x.Len == nil {
			return types.NewSlice(elt)
		}
		bl, ok := x.Len.(*ast.BasicLit)
		if !ok || bl.Kind != token.INT {
			panic(fmt.Sprintf("TODO: %T", x))
		}
		len, _ := strconv.ParseInt(bl.Value, 0, 0)
		return types.NewArray(elt, len)
	case *ast.StarExpr:
		return types.NewPointer(g.resolveType(scope, x.X))
	case *ast.ChanType:
		dir := types.SendRecv
		switch x.Dir {
		case ast.SEND:
			dir = types.SendOnly
		case ast.RECV:
			dir = types.RecvOnly
		}
		return types.NewChan(dir, g.resolveType(scope, x.Value))
	case *ast.SelectorExpr:
		scope = g.findScope(scope, x.X)
		return g.resolveType(scope, x.Sel)
	default:
		panic(fmt.Sprintf("resolveType TODO: %T", x))
	}
}

func (g *G) findScope(scope *types.Scope, expr ast.Expr) *types.Scope {
	switch x := expr.(type) {
	case *ast.Ident:
		_, obj := scope.LookupParent(x.Name, token.NoPos)
		if pkg, ok := obj.(*types.PkgName); ok {
			return pkg.Imported().Scope()
		}
		// try to fall back to std
		if g.stdImporter == nil {
			g.stdImporter = importer.Default()
		}
		path := x.Name
		if longer, ok := stdImportFixes[path]; ok {
			path = longer
		}
		pkg, err := g.stdImporter.Import(path)
		if err != nil {
			panic(fmt.Sprintf("findScope err: %v", err))
		}
		return pkg.Scope()
	default:
		panic(fmt.Sprintf("findScope TODO: %T", x))
	}
}

var stdImportFixes = map[string]string{
	// go list std | grep -vE 'vendor|internal' | grep '/' | sed -r 's@^(.*)/([^/]*)$@"\2": "\1/\2",@' | sort
	// (after commenting out the less likely duplicates)
	"adler32":   "hash/adler32",
	"aes":       "crypto/aes",
	"ascii85":   "encoding/ascii85",
	"asn1":      "encoding/asn1",
	"ast":       "go/ast",
	"atomic":    "sync/atomic",
	"base32":    "encoding/base32",
	"base64":    "encoding/base64",
	"big":       "math/big",
	"binary":    "encoding/binary",
	"bits":      "math/bits",
	"build":     "go/build",
	"bzip2":     "compress/bzip2",
	"cgi":       "net/http/cgi",
	"cgo":       "runtime/cgo",
	"cipher":    "crypto/cipher",
	"cmplx":     "math/cmplx",
	"color":     "image/color",
	"constant":  "go/constant",
	"cookiejar": "net/http/cookiejar",
	"crc32":     "hash/crc32",
	"crc64":     "hash/crc64",
	"csv":       "encoding/csv",
	"debug":     "runtime/debug",
	"des":       "crypto/des",
	"doc":       "go/doc",
	"draw":      "image/draw",
	"driver":    "database/sql/driver",
	"dsa":       "crypto/dsa",
	"dwarf":     "debug/dwarf",
	"ecdsa":     "crypto/ecdsa",
	"elf":       "debug/elf",
	"elliptic":  "crypto/elliptic",
	"exec":      "os/exec",
	"fcgi":      "net/http/fcgi",
	"filepath":  "path/filepath",
	"flate":     "compress/flate",
	"fnv":       "hash/fnv",
	"format":    "go/format",
	"gif":       "image/gif",
	"gob":       "encoding/gob",
	"gosym":     "debug/gosym",
	"gzip":      "compress/gzip",
	"heap":      "container/heap",
	"hex":       "encoding/hex",
	"hmac":      "crypto/hmac",
	"http":      "net/http",
	"httptest":  "net/http/httptest",
	"httptrace": "net/http/httptrace",
	"httputil":  "net/http/httputil",
	"importer":  "go/importer",
	"iotest":    "testing/iotest",
	"ioutil":    "io/ioutil",
	"jpeg":      "image/jpeg",
	"json":      "encoding/json",
	"jsonrpc":   "net/rpc/jsonrpc",
	"list":      "container/list",
	"lzw":       "compress/lzw",
	"macho":     "debug/macho",
	"mail":      "net/mail",
	"md5":       "crypto/md5",
	"multipart": "mime/multipart",
	"palette":   "image/color/palette",
	"parser":    "go/parser",
	"parse":     "text/template/parse",
	"pe":        "debug/pe",
	"pem":       "encoding/pem",
	"pkix":      "crypto/x509/pkix",
	"plan9obj":  "debug/plan9obj",
	"png":       "image/png",
	//"pprof":   "net/http/pprof",
	"pprof":           "runtime/pprof",
	"printer":         "go/printer",
	"quick":           "testing/quick",
	"quotedprintable": "mime/quotedprintable",
	"race":            "runtime/race",
	//"rand":          "crypto/rand",
	"rand": "math/rand",
	"rc4":  "crypto/rc4",
	"ring": "container/ring",
	"rpc":  "net/rpc",
	"rsa":  "crypto/rsa",
	//"scanner":   "go/scanner",
	"scanner":     "text/scanner",
	"sha1":        "crypto/sha1",
	"sha256":      "crypto/sha256",
	"sha512":      "crypto/sha512",
	"signal":      "os/signal",
	"smtp":        "net/smtp",
	"sql":         "database/sql",
	"subtle":      "crypto/subtle",
	"suffixarray": "index/suffixarray",
	"syntax":      "regexp/syntax",
	"syslog":      "log/syslog",
	"tabwriter":   "text/tabwriter",
	"tar":         "archive/tar",
	//"template":  "html/template",
	"template":  "text/template",
	"textproto": "net/textproto",
	"tls":       "crypto/tls",
	"token":     "go/token",
	"trace":     "runtime/trace",
	"types":     "go/types",
	"url":       "net/url",
	"user":      "os/user",
	"utf16":     "unicode/utf16",
	"utf8":      "unicode/utf8",
	"x509":      "crypto/x509",
	"xml":       "encoding/xml",
	"zip":       "archive/zip",
	"zlib":      "compress/zlib",
}

func maybeNilIdent(x *ast.Ident) ast.Node {
	if x == nil {
		return nil
	}
	return x
}

func bothValid(p1, p2 token.Pos) bool {
	return p1.IsValid() == p2.IsValid()
}

// nodes matches two lists of nodes. It uses a common algorithm to match
// wildcard patterns with any number of nodes without recursion.
func (g *G) nodes(ns1, ns2 gsyntax.NodeList, partial bool) ast.Node {
	ns1len, ns2len := ns1.Len(), ns2.Len()
	if ns1len == 0 {
		if ns2len == 0 {
			return ns2
		}
		return nil
	}
	partialStart, partialEnd := 0, ns2len
	i1, i2 := 0, 0
	next1, next2 := 0, 0

	// We need to keep a copy of g.values so that we can restart
	// with a different "any of" match while discarding any matches
	// we found while trying it.
	type restart struct {
		matches      map[string]ast.Node
		next1, next2 int
	}
	// We need to stack these because otherwise some edge cases
	// would not match properly. Since we have various kinds of
	// wildcards (nodes containing them, $_, and $*_), in some cases
	// we may have to go back and do multiple restarts to get to the
	// right starting position.
	var stack []restart
	push := func(n1, n2 int) {
		if n2 > ns2len {
			return // would be discarded anyway
		}
		stack = append(stack, restart{valsCopy(g.values), n1, n2})
		next1, next2 = n1, n2
	}
	pop := func() {
		i1, i2 = next1, next2
		g.values = stack[len(stack)-1].matches
		stack = stack[:len(stack)-1]
		next1, next2 = 0, 0
		if len(stack) > 0 {
			next1 = stack[len(stack)-1].next1
			next2 = stack[len(stack)-1].next2
		}
	}
	wildName := ""
	wildStart := 0

	// wouldMatch returns whether the current wildcard - if any -
	// matches the nodes we are currently trying it on.
	wouldMatch := func() bool {
		switch wildName {
		case "", "_":
			return true
		}
		list := ns2.Slice(wildStart, i2)
		// check that it matches any nodes found elsewhere
		prev, ok := g.values[wildName]
		if ok && !g.node(prev, list) {
			return false
		}
		g.values[wildName] = list
		return true
	}
	for i1 < ns1len || i2 < ns2len {
		if i1 < ns1len {
			n1 := ns1.At(i1)
			id := fromWildNode(n1)
			info := g.info(id)
			if info.any {
				// keep track of where this wildcard
				// started (if info.name == wildName,
				// we're trying the same wildcard
				// matching one more node)
				if info.name != wildName {
					wildStart = i2
					wildName = info.name
				}
				// try to match zero or more at i2,
				// restarting at i2+1 if it fails
				push(i1, i2+1)
				i1++
				continue
			}
			if partial && i1 == 0 {
				// let "b; c" match "a; b; c"
				// (simulates a $*_ at the beginning)
				partialStart = i2
				push(i1, i2+1)
			}
			if i2 < ns2len && wouldMatch() && g.node(n1, ns2.At(i2)) {
				wildName = ""
				// ordinary match
				i1++
				i2++
				continue
			}
		}
		if partial && i1 == ns1len && wildName == "" {
			partialEnd = i2
			break // let "b; c" match "b; c; d"
		}
		// mismatch, try to restart
		if 0 < next2 && next2 <= ns2len && (i1 != next1 || i2 != next2) {
			pop()
			continue
		}
		return nil
	}
	if !wouldMatch() {
		return nil
	}
	return ns2.Slice(partialStart, partialEnd)
}

func (g *G) nodesMatch(list1, list2 gsyntax.NodeList) bool {
	return g.nodes(list1, list2, false) != nil
}

func (g *G) exprs(exprs1, exprs2 []ast.Expr) bool {
	return g.nodesMatch(gsyntax.ExprList(exprs1), gsyntax.ExprList(exprs2))
}

func (g *G) idents(ids1, ids2 []*ast.Ident) bool {
	return g.nodesMatch(gsyntax.IdentList(ids1), gsyntax.IdentList(ids2))
}

func toStmtList(nodes ...ast.Node) gsyntax.StmtList {
	var stmts []ast.Stmt
	for _, node := range nodes {
		switch x := node.(type) {
		case nil:
		case ast.Stmt:
			stmts = append(stmts, x)
		case ast.Expr:
			stmts = append(stmts, &ast.ExprStmt{X: x})
		default:
			panic(fmt.Sprintf("unexpected node type: %T", x))
		}
	}
	return gsyntax.StmtList(stmts)
}

func (g *G) cases(stmts1, stmts2 []ast.Stmt) bool {
	for _, stmt := range stmts2 {
		switch stmt.(type) {
		case *ast.CaseClause, *ast.CommClause:
		default:
			return false
		}
	}
	var left []*ast.Ident
	for _, stmt := range stmts1 {
		var expr ast.Expr
		var bstmt ast.Stmt
		switch x := stmt.(type) {
		case *ast.CaseClause:
			if len(x.List) != 1 || len(x.Body) != 1 {
				return false
			}
			expr, bstmt = x.List[0], x.Body[0]
		case *ast.CommClause:
			if x.Comm == nil || len(x.Body) != 1 {
				return false
			}
			if commExpr, ok := x.Comm.(*ast.ExprStmt); ok {
				expr = commExpr.X
			}
			bstmt = x.Body[0]
		default:
			return false
		}
		xs, ok := bstmt.(*ast.ExprStmt)
		if !ok {
			return false
		}
		bodyIdent, ok := xs.X.(*ast.Ident)
		if !ok || bodyIdent.Name != "gogrep_body" {
			return false
		}
		id, ok := expr.(*ast.Ident)
		if !ok || !isWildName(id.Name) {
			return false
		}
		left = append(left, id)
	}
	return g.nodesMatch(gsyntax.IdentList(left), gsyntax.StmtList(stmts2))
}

func (g *G) stmts(stmts1, stmts2 []ast.Stmt) bool {
	return g.nodesMatch(gsyntax.StmtList(stmts1), gsyntax.StmtList(stmts2))
}

func (g *G) specs(specs1, specs2 []ast.Spec) bool {
	return g.nodesMatch(gsyntax.SpecList(specs1), gsyntax.SpecList(specs2))
}

func (g *G) fields(fields1, fields2 *ast.FieldList) bool {
	var list1, list2 gsyntax.FieldList
	if fields1 != nil {
		list1 = fields1.List
	}
	if fields2 != nil {
		list2 = fields2.List
	}
	return g.nodesMatch(list1, list2)
}

func fromWildNode(node ast.Node) int {
	switch node := node.(type) {
	case *ast.Ident:
		return fromWildName(node.Name)
	case *ast.ExprStmt:
		return fromWildNode(node.X)
	case *ast.Field:
		// Allow $var to represent an entire field; the lone identifier
		// gets picked up as an anonymous field.
		if len(node.Names) == 0 && node.Tag == nil {
			return fromWildNode(node.Type)
		}
	}
	return -1
}
